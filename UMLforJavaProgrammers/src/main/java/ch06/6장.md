## 나쁜 설계의 냄새
1. **경직성**: 무엇이든 하나를 바꿀 때마다 반드시 다른 것도 바꿔야 하며, 그러고 나면 또 다른 것도 바꿔야 하는 변화의 사슬이 끊이지 않기 때문에 시스템을 변경하기 힘들다.
2. **부서지기 쉬움**: 시스템에서 한 부분을 변경하면 그것과 전혀 상관없는 다른 부분이 작동을 멈춘다.
3. **부동성**: 시슽메이 여러 컴포넌트로 분해해서 다른 시스템에 재사용하기 힘들다.
4. **끈끈함**: 개발 환경이 배관용 테이프나 풀로 붙인 것처럼 꽉 달라붙은 상태다. (편집-컴파일-테스트 순환을 한번 도는 시간이 엄청나게 길다.)
5. **쓸데없이 복잡함**: 괜히 머리를 굴려서 짠 코드 구조가 굉장히 많다. 이것들은 대개 지금 당장 하나도 필요 없지만 언젠가는 굉장히 유용할지도 모른다고 기대하며 만든 것이다.
6. **필요 없는 반복**: 코드를 작성한 프로그래머 이름이 마치 '복사'와 '붙여넣기'같다.
7. **불투명함**: 코드를 만든 의도에 대한 설명을 볼 때 그 설명에 '표현이 꼬인다'라는 말이 잘 어울린다.

## 단 하나의 책임 원칙(The Single Responsibility Principle, SRP)
- **어떤 클래스는 변경해야 하는 이유는 오직 하나뿐이어야 한다.**

## 개방 - 폐쇄 원칙(The Open - Closed Principle, OCP)
- **소프트웨어 엔티티(클래스, 모듈, 함수 등)는 확장에 대해서는 개방되어야 하지만, 변경에 대해서는 폐쇄되어야 한다.**

## 리스코프 교체 원칙(Liskov Subtitution Principle, LSP)
- **서브타입은 언제나 자신의 기반 타입(base type)으로 교체할 수 있어야 한다.**

## 의존 관계 역전 원칙(Dependency Inversion Principle, DIP)
- **고차원 모듈은 저차원 모듈에 의존하면 안 된다. 이 두 모듈 모두 다른 추상화된 것에 의존해야 한다.**
- **추상화된 것은 구체적인 것에 의존하면 안 된다. 구체적인 것이 추상화된 것에 의존해야 한다.**

## 인터페이스 격리 원칙(Interface Segregation Principle, ISP)
- **클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안 된다.**

## 결론
1. SRP - 어떤 클래스를 변경해야 할 이유는 오직 하나뿐이어야 한다.
2. OCP - 클래스를 변경하지 않고도 그 클래스의 환경을 바꿀 수 있어야 한다.
3. LSP - 유도된 클래스의 메서드를 토화시키거나 불법으로 만드는 일을 피하라. 기반 클래스의 사용자는 그 기반 클래스에서 유도된 클래스에 대해 아무것도 알 필요가 없어야 한다.
4. DIP - 자주 변경하는 컨크리트 클래스 대신 인터페이스나 추상 클래스에 의존하라.
5. ISP - 어떤 객체의 사용자에게 그 사용자한테 필요한 메서드만 있는 인터페이스를 제공하라.

- 언제 이 원칙들을 적용해야 할까? 조금이라도 고통을 느끼기 시작하면 바로 해야한다. 전체 시스템이 언제나 모든 원칙을 따르게끔 노력하는 것은 현명하지 못하다. OCP를 적용할 상이한 환경을 모두 상상하거나 SRP를 적용할 모든 변경의 이유를 생각해 내려면 시간이 끝도 없이 걸릴 것이다. ISP를 지키기 위해서 자잘한 인터페이스를 몇십 몇백 개 만들게 될 테고, DIP를 지키기 위해서 쓸모없는 추상을 무수히 만들게 될 것이다. 이 원칙들을 적용하는 가장 좋은 방법은 능동적으로 적극 적용하는 것이 아니라, 문제가 생겼을 때 그에 대한 '반응으로써 적용'하는 것이다. 코드의 구조적인 문제를 처음 발견했거나, 어떤 모듈이 다른 모듈에서 생긴 변화에 영향을 받음을 처음 깨달았을 때 그때 '비로소' 원칙 가운데 하나 또는 여러 개를 써서 이 문제를 해결할 수 있는지 알아보아야 한다. 물론, 이렇게 문제가 생겨야 비로소 반응하는 접근 방법을 쓰기로 한다면, 초기에 고통을 느낄 수 있도록 시스템에 '적극적으로 ' 압력을 가해야 한다. 어디가 아픈지 부지런히 눌러 봐야 문제들을 충분히 발견할 수 있기 때문이다. 단위 테스트를 엄청나게 작성해 보는 것이 아픈 지점을 찾는 가장 좋은 방법 가운데 하나다. 테스트 대상 코드보다 테스트를 먼저 작성하면 더 좋다.